1.python中，定义变量时不需要指定变量的类型，在运行的时候，Python解释器会根据赋值语句等号右侧的数据自动推导出变量中保存数据的准确类型。

2.Python中数据类型可以分为数字型和非数字型

数字型

    整型（int）

    浮点型（float）

    布尔型（bool）

    复数型（complex）

非数字型

    字符串

    列表

    元组

    字典

3.使用type函数可以查看一个变量的类型

4.python3.x中，整数无long 和int之分，全为int

5..不同变量之间的计算

    （1）python中，两个数字变量是可以直接进行算数运算的

    如果变量是bool型，在计算时

        True对应数字1

        False对应数字2

    （2）字符串变量之间使用+拼接生成新的字符串

    （3）字符串变量可以和整数使用 * 重复拼接相同的字符串

                    ”—“*50

    （4）数字型变量和字符串之间不能进行其他运算

6.变量输入

    python中，获取用户在键盘上输入的信息，需要使用input函数

    字符串变量 = input(”提示信息：“)

    input得到的数据类型都是字符串类型

7.类型转换函数

    int(x):将x转换为一个整数

    int(x):将x转换为一个浮点数

8.变量的格式化输出

    %s：字符串

    %d：有符号十进制整数，%06d表示输出的整数显示位数，不足的地方使用0补全。06d超过6位，就该怎么显示就怎么显示

    %f：浮点数，%.02f表示小数点后只显示两位

    %%：输出%

    print（i）

    print（”请输入数字%d，再输入数字%d“ % （a，b））

    **语法格式**

    print（"格式化字符串" %变量1）

    print（”格式化字符串“%（变量1，变量2，））

    print("%d * %d = %d" %(col,row,col*row)，end="\t")

9.关键字

    通过以下命令可以查看python中关键字

        import  keyword

        printf（keyword.kwlist）

10.if语句

if 条件1：

    条件1满足执行的代码

elif 条件2：

    条件2满足执行的代码

elif 条件3：

    条件3满足执行的代码

else：

    以上都不满足的代码

and 与    or 或   not 非

11.while语句

while 条件（判断 计数器 是否达到 目标次数）:

    条件满足时，做的事情

    处理条件（计数器+1）

12.赋值运算符

    =   +=  -=

    *****=      c*=a等于 c=c*a

    /=       c/=a等于  c=c/a

    //=   取整除赋值运算符  c//=a等于c=c//a

    %=    取模（余数）赋值运算符  c%=a等于c=c%a

    **=    幂赋值运算符    c****=a等于c=c**a

13.break和continue

    break：某一条件满足时，退出循环，不再执行后续重复的代码。直接退出所有循环

    continue：某一条件满足时，不执行后续重复的代码。退出这一次。

    注意:使用continue时，在使用关键字之前，需要确认循环的计数是否修改，否则可能导致死循环。

14.print扩展

    在默认情况下，print函数输出内容之后，会自动在内容末尾增加换行。如果不希望末尾增加换行，可以在print函数输出内容的后面增加，end=” “。其中end=” “中间可以指定print函数输出内容之后，继续希望显示的内容。

    print（”*“，end=”“） 向控制台输出内容结束后，不会换行

    print（”“）单纯的换行

15.转义字符

    \t 在控制台输出一个制表符，协助在输出文本时 垂直方向 保持对齐

    \n在控制台输出一个换行符

    \\\ 反斜杠符号

    \'单引号

    \"双引号

    \n换行

    \t横向制表符

    \r回车

16.函数

**16.1定义函数的格式如下**

    def    函数名():

        函数封装的代码

        ......

    四个空格缩进

    注意：定义好函数之后，之表示这个函数封装了一段代码而已。如果不主动调用函数，函数不会主动执行的。

**16.2函数调用**

    调用函数很简单的，通过 函数名()  即可完成函数的调用。

     函数调用不能放到函数定义上方

**16.3函数注释**

    在定义函数下一行加入函数注释用”““   ”“”

    开发中，如果希望给函数添加注释，应该在定义函数的下方，使用连续的三对引号。在连续的三对引号之间编写对函数的说明文字。在函数调用位置。使用快捷键Ctrl+Q可以查看函数说明信息。

    **注意**:因为函数相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留两个空行。

**16.4函数的参数**

    函数名后面的小括号内部填写**参数**

    多个参数之间使用，分隔

    def    sum(num1,num2)

        num1、num2就可以直接当变量使用。

    **形参**：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量时使用。

    **实参**：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的

**16.5.函数返回值**

    在函数中使用return关键字返回结果，在调用一方，可以使用变量来接收函数的返回结果

    **注意**：return表示返回，后续的代码都不会被执行。

**17.模块**

    模块时python程序架构的一个核心概念

    模块就好比工具包，要想使用这个工具包中的工具，就需要导入import这个模块

    每一个以扩展名py结尾的python源代码文件都是一个模块

    在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具。

    导入之后，可以使用**模块名.变量**/**模块名.函数**的方式，只用这个模块中定义的变量或函数。

    **注意**：模块名也是一个标识符

    标识符可以由字母、下划线和数字组成。不能以数字开头、不能与关键字重名。

**18.pyc**

    c是compiled编译过的意思

    pyc文件是由python解释器将模块代码转换为字节码，python这样保存字节码是作为一种启动速度的优化。

**19.列表**

    定义 ：

    namelist=["zhangsan","lisi","wangwu"]

    列表的索引从0开始的

    **列表可以修改**

    列表一般存储数据类型一样的数据，但也可以存储不同。与C语言中的数组一样。

    遍历列表：

    for  name  in  namelist:

        #for循环内部使用的变量in列表

        print(name)

**20.元组**

    定义：

    元组用（）定义，元组的索引从0开始

    info_tuple=("zhangsan",18,1.75)

    创建空元组：tuple=()

    创建只包含一个元素时，需要在元素后面添加都好

    info_tuple=(50,)

    循环变量

    for  item  in  info：

        print(item)

    **注意**：在python中，可以使用for循环遍历所有非数字类型的变量：列表、元组、字典以及字符串。在实际开发中，除非能够 确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多

**元组不可以修改**

格式化字符串：

    info_tuple=(“小明”，21，1.85)

    print(“%s 年龄是 %d 身高是 %.2f” %info_tuple)     

**21.元组和列表的转换**

    使用list函数可以把元组转换成列表：list（元组）

    使用tuple函数可以把列表转换为元组：tuple（列表）

**22.字典**

    字典是键值对

    列表是有序的对象集合，字典是无序的对象集合

    字典使用{}定义

    字典使用键值对存储数据，键值对之间使用，分隔

        键 key 是索引

        值value是数据

        键是唯一的，键和值之间使用：分隔，值可以取任何数据类型，但键只能使用字符串、数字或元组

    xiaoming={“name”：“小明”，

                         “age”：18，    

                          “gender”：True                    

                          “height”：1.75}

**取值**：print（xiaoming["name"]）

**增加/修改**：xiaoming[“age1”]=18

                     xiaoming["name"]=“小小明”

**删除**：xiaoming.pop(“name”)

        如果key不存在，会增加键值对；如果key存在会修改已经存在的键值对。

    字典是一个无序的集合，使用print函数输出字典时，通常输出的顺序和定义的顺序是不一致的！

len统计字典中键值对的对数

update合并字典，如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对。

clear清空字典中所有的键值对清空

**遍历字典**：

变量k是每次循环中，获取到的键值对key

    for  k  in  xiaoming：

        print（“%s - %s” %(k，xiaoming[k])）   

**23.字符串**

     python一对单引号 或者 一对双引号定义一个字符串 。大多数编程语言使用双引号定义字符串。

    定义：

    str1 = “hello python”

    for c in string：

        print（c）

    取字符串中的数据可以按照列表的方式取值

    len（字符串）获取字符串长度

    字符串.count（字符串）小字符串在大字符串中出现的次数

    字符串[索引]从字符串中取出单个字符

    字符串.index（字符串）获得小字符串第一次出现的索引

    字符串切片：字符串[开始索引：结束索引：步长]

    num_str="0123456789"

    num_str[2:6]

    num_str[::2 ]

**24.公共方法**

**python内置函数**：

    len（item）：计算容器中元素个数

    del（item）：删除变量   del有两种使用方式

        a=[1，2，3]    

        del a[1]

        del(a[1])

        del(a)

    max（item）：返回容器中元素最大值；如果是字典，只针对key比较

    min（item）：返回容器中元素最小值；如果是字典，只针对key比较

    cmp（item1，item2）：比较两个值，-1小于/0相等/1大于   python3.x取消了cmp函数    

    字符、字符串、列表、元组都可以比较大小，但是字典不能比较大小

**切片**：

    字符串、列表、元组都可以切片，字典不能切片，因为字典为无序的集合。

**运算符**：

![](C:\Users\li'xin\AppData\Roaming\marktext\images\2022-09-11-13-55-16-image.png)

in在对字典操作时，判断的是字典的键

in和not in被称为成员运算符

**完整的for循环语法**：

for  变量  in  集合：

    循环体代码

else：

    没有通过break退出循环，循环结束后，会执行的代码

**25.应用实例** 

字符串判断 ： if  action  in  ["1","2","3"]  等于 if action == "1" or action == "2" or action == "3" 

pass语句：是一个空语句，不做任何事情，一般用作占位语句，为保持程序结构的完整性。

return:如果return后面没有任何的内容，表示会返回到调用函数的位置，并且不返回任何的结果。 

**26.SHebang**

    符号：#！

    #！python3的路径   ：就可以直接使用./运行python脚本。

**27.变量的高级应用**

    变量和数据是分开存储的，数据保存在内存中的一个位置，变量中保存着数据在内存中的地址，变量记录数据的地址，就叫做引用。

    使用id（）函数可以查看变量中保存数据所在的内存地址

**注意**：如果变量已经被定义，当一个变量赋值的时候，本质上是 修改了数据的 引用；变量不再对之前的数据引用，变量改为对新赋值的数据引用。

**数据的地址本质上就是一个数字**

**调用函数传递实参的引用**：调用函数时，本质上传递的是实参保存数据的引用，而不是实参保存的数据！

**注意**：如果函数有返回值，但没有定义变量接收；程序不会报错，但无法获得返回结果。

**28.可变和不可变类型**

    **不可变类型**：内存中数据不允许修改

    数字类型：int、bool、float、complex、long（2.x）

    字符串：str

    元组：tuple

    **可变类型**：内存中的数据可以被修改

    列表：list

    字典：dict

其中，改变列表、字典中的值，不会改变内存的地址（引用）。如果通过赋值改变列表值，会改变该列表在内存中的地址。（字典与列表一样）

1.可变类型数据变化，是通过方法来实现的

2.如果给一个可变类型的变量，赋值了一个新的数据，引用会修改

    变量不再对之前的数据引用，变量改为对新赋值的数据引用。    

**字典中的key只能使用不可变类型的数据，列表、字典都不能作为key，字典中的值可以是任意类型**

**29.哈希（hash）**

    python中内置的一个函数，接收一个不可变类型的数据作为参数，返回结果是一个整数。

    哈希是一种算法，其作用就是提取数据的特征码，相同的内容得到相同的结果，不同的内容得到不同的结果。

**30.局部变量和全局变量**

    局部变量是在函数内部定义的变量，只能在函数内部使用。

    全局变量是在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量

**局部变量的生命周期**：

    所谓生命周期就是从被创建到被系统回收的过程，局部变量在函数执行时才会被创建，函数执行结束后局部变量被系统回收，局部变量在生命周期内，可以用来存储函数内部临时使用到的数据。

    不同函数，可以定义相同的名字的局部变量，但是彼此之间不会产生影响。

**全局变量**：

    **在其他开发语言中，大多不推荐使用全局变量--可变范围太大，导致程序不好维护**

    **在python的函数内部，可以通过全局变量的引用获取对应的数据，但是，不允许直接修改全局变量的引用--使用赋值语句修改全局变量的值**

     python中不允许直接修改全局变量的值；如果在函数中使用赋值语句，会在函数内部，定义一个局部变量。

    **使用global关键字，告诉Python解释器num是一个全局变量**：global num  就可以在函数内部修改全局变量num的值。

    在开发时，应该把模块中的所有全局变量定义在所有函数上方，就可以保证所有函数能够正常访问到每一个全局变量。

    建议全局变量定义为g_xx或者gl_xx

**31.代码结构图**

<img title="" src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-11-21-08-59-image.png" alt="" width="171">

**32.函数的高级应用**

    如果函数内部处理的数据不确定，可以将外界的数据以参数传递到函数内部

    如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值

    -------------------------------------------------------------------------------------------------------------

    元组-可以包含多个数据，因此可以使用元组让函数一次返回多个值，如果函数返回的类型时元组，小括号可以省略。

    如果函数返回的类型是元组，同时希望单独的处理元组中的元素，可以使用多个变量，一次接收函数的返回结果。

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-11-21-22-44-image.png" title="" alt="" width="376">

不使用其他变量交换a b变量值

    C语言解法

    a=a+b

    b=a-b

    a=a-b

    python语言解法

    a，b=（b，a）    

        变形

    a，b=b，a 

**33.可变变量和不可变变量**

    **注意**：

        在函数内部，针对参数使用赋值语句，不会修改到外部的实参变量。

        如果传递的参数是可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据。    

        列表变量使用+=不会做相加再赋值的操作！本质上是在调用列表的ectend方法。

**34.缺省参数**

    定义：定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数。

    函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用。

    举例：

    def  print_info(name，gender=True)

        函数处理代码

    **注意**：

    缺省参数定义的位置必须保证带有默认值的缺省参数在参数列表末尾

    在调用函数时，如果有多个缺省参数，需要指定参数名，这样解释才能够知道参数的对应关系！

**35.多值参数**

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-12-16-47-17-image.png" title="" alt="" width="601">

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-12-16-51-26-image.png" title="" alt="" width="252">

多值参数的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们读懂大牛的代码。

**元组和字典的拆包**

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-12-17-20-06-image.png" title="" alt="" width="405">

**36.函数的递归**

    定义：函数调用自身编程技巧称为递归

    **递归函数的特点**

    一个函数内部调用自己

        函数内部可以调用其他函数，当然也可以调用自己

    **代码特点**

    1.函数内部的代码是相同的，只是针对参数不同，处理的结果不同

    2.当参数满足一个条件时，函数不再执行。

        *这个非常重要，通常被称为递归的出口，否则会出现死循环。*

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-12-19-24-28-image.png" title="" alt="" width="314">

**37.大驼峰命名法**

    每个单词的首字母大写

    单词与单词之间没有下划线

**38.面向对象（OOP）**

    相比较函数，面向对象 是更大的封装，根据职责在一个对象中封装多个方法

**39.类和对象**

    类和对象是面向对象编程的两个核心概念。

    **类**：是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用

        特征被称为属性，行为被称为方法 

    **对象**：是由类创建出来的一个 具体的存在，可以直接使用

        由哪一个类创建出来的对象，就拥有在哪一个类中定义的：属性、方法 

    **关系**：类是模板，对象是根据这个模板创建出来的，应该先有类、再有对象。

        类只有一个，而对象可以有很多个。不同的对象之间的属性可能各不相同

        类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。 

**40.dir内置函数**

    python中对象几乎是无所不在的，我们之前学习的变量、数据、函数都是对象

    在python中可以使用以下两个方法验证：

    1.在标识符/数据后输入一个 . ，然后按下TAB键，ipython会提示该对象能够调用的方法列表

    2.使用内置函数dir传入标识符/数据，可以查看对象内的所有属性和方法。 

    _ _方法名__格式的方法是python提供的内置方法和属性。

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-12-22-11-47-image.png" title="" alt="" width="566">、

**41.定义**

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-12-22-35-54-image.png" title="" alt="" width="509">

创建对象

 当一个类定义完成之后，要使用这个类来创建对象，通用格式如下：

    对象变量=类名（）

    使用同一个类定义两个对象，这两个对象不是同一个对象。

**在类的外部给对象增加属性**：可以使用 . 属性名 利用赋值语句就可以

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-13-11-33-35-image.png" title="" alt="" width="499">

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-13-11-36-34-image.png" title="" alt="" width="482">

**注意**：

    在日常开发中，不推荐存在类的外部给对象增加属性，如果在运行时，没有找到属性，程序会报错。

    对象应该包含哪些属性，应该封装在类的内部。

**42.初始化方法**

当使用 类名（）创建对象时，会自动执行以下操作：

    1.为对象在内存中分配空间——创建对象

    2.为对象的属性 设置初始值——初始化（init）

这个初始值方法就是_ _init__方法，__init__是对象的内置方法

    __init__方法是专业用来定义一个类具有哪些属性的方法！

在__init__中添加属性，该类创建的所有对象都包含该属性。

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-13-20-42-00-image.png" title="" alt="" width="476">

**43.内置方法和属性**

__del__对象被从内存中销毁前，会自动被调用

__str__返回对象的描述信息，print函数输出使用

del关键字可以删除一个对象

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-13-20-51-58-image.png" title="" alt="" width="484">

__str__必须返回一个字符串

**注意**：在对象的方法内部，是可以直接访问对象的属性的！

            同一个类创建的多个对象之间，属性互补干扰！

Python能够自动的将第一对括号内部的代码连接在一起

**43.注意事项**

**定义没有初始值的属性**

在定义属性时，如果不知道设置什么初始值，可以设置为None

    None关键字表示什么都没有

    表示一个空对象，没有方法和属性，是一个特殊的常量

    可以将None赋值给任何一个变量

**在发封装的方法内部，还可以让自己的 使用其它类创建的对象属性 调用 封装好的方法**

**44.身份运算符**

身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 —— **是否是对同一个对象的引用**

- 在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

- | is  | is 是判断两个标识符是不是引用同一个对象 |
  | --- | --------------------- |
  
  | is not | is not 是判断两个标识符是不是引用不同对象 |
  | ------ | ------------------------ |
  
  ##### is 与 == 区别：
  
  `is` 用于判断 **两个变量 引用对象是否为同一个**  
  `==` 用于判断 **引用变量的值** 是否相等

**45.私有属性和私用方法**

    在实际开发中，**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部被使用**，而 **不希望在外部被访问到**

    **私有属性** 就是 **对象** 不希望公开的 **属性**

    **私有方法** 就是 **对象** 不希望公开的 方法  

定义方法：在定义属性或者方法时，在属性名或者方法名前增加两个下划线，定义的就是私有属性和方法

         __age       

        __secret(self):

在对象的方法内部，时可以访问对象的私有属性 

**私有方法和属性的调用**：_类名__名称

**46.继承**

**面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中

2. **继承** **实现代码的重用**，相同的代码不需要重复的编写

3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**

**47.单继承**

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

1. 继承的语法
   
   class 类名（父类名）：
   
       pass
- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发

- **子类** 中应该根据 **职责**，封装 **子类特有的** **属性和方法**

2.继承的传递性

     **子类** 拥有 **父类** 以及 **父类的父类** 中封装的所有 **属性** 和 **方法**

     **子类**不能继承表亲戚的类，只能直系。    

3.方法的重写

- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发

    当父类的方法不能满足子类的需求时，可以对方法进行重写    

    **重写** 父类方法有两种情况：

        **覆盖**父类的方法：如果子类中，重写了父类的方法，在使用子类对象调用方法时，会调用子类中重写的方法。

        对父类方法进行 **扩展**：

            **在子类中** **重写** 父类的方法

            在需要的位置使用 `super().父类方法` 来调用父类方法的执行

            代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-14-12-00-22-image.png" title="" alt="" width="319">

    python2.x支持的方式：父类名.方法（self）；Python3.x还支持这种方法，但是不推荐使用该方法。

4.父类的 私有属性 和 私有方法

1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**

2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

**48.多继承**

概念：

- **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**

- 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**

语法：

    class    子类名（父类·名1，父类名2......）

        pass

多继承可以让子类对象，同时具有多个父类的属性和方法

**注意**：**开发时，应该尽量避免这种容易产生混淆的情况！** —— 如果 **父类之间** 存在 **同名的属性或者方法**，应该 **尽量避免** 使用多继承

**知道就行**

- `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序

- MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**
  
  print(C.__mro__)

(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)

- 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的

- 如果在当前类中 **找到方法，就直接执行，不再搜索**

- 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**

- 如果找到最后一个类，还没有找到方法，程序报错

**注意**：为了保证编写的代码能够同时在 `Python 2.x` 和 `Python 3.x` 运行！今后在定义类时，**如果没有父类，建议统一继承自** **object**

    class 类名(object):
        pass

**49.多态**

**面向对象三大特性**

**多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果

    **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中

        定义类的准则

**继承** **实现代码的重用**，相同的代码不需要重复的编写

        设计类的技巧

        子类针对自己特有的需求，编写特定的代码

**多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果

        **多态** 可以 **增加代码的灵活度**

        以 **继承** 和 **重写父类方法** 为前提

        是调用方法的技巧，**不会影响到类的内部设计**

**50.类属性和类方法**

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-14-15-06-37-image.png" title="" alt="" width="396">

1. 创建出来的 **对象** 叫做 **类** 的 **实例**

2. 创建对象的 **动作** 叫做 **实例化**

3. **对象的属性** 叫做 **实例属性**

4. **对象调用的方法** 叫做 **实例方法**

**注意**：

    每一个对象都有自己独立的内存空间，保存各自不同的属性

    多个对象的方法，在内存中只要一份，在调用方法时，需要把对象的引用传递到方法的内部。

**类是一个特殊的对象**

`Python` 中 **一切皆对象**：

- `class AAA:` 定义的类属于 **类对象**

- `obj1 = AAA()` 属于 **实例对象**

- 除了封装 **实例** 的 **属性** 和 **方法**外，**类对象** 还可以拥有自己的 **属性** 和 **方法**
1. **类属性**
2. **类方法**

   **类属性**

- 通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

<img src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-14-16-13-33-image.png" title="" alt="" width="364">

<img title="" src="file:///C:/Users/li'xin/AppData/Roaming/marktext/images/2022-09-14-16-36-23-image.png" alt="" width="487" data-align="inline">

**注意**：

- 如果使用 `对象.类属性 = 值` 赋值语句，只会 **给对象添加一个属性**，而不会影响到 **类属性的值**

**类方法**

**类方法** 就是针对 **类对象** 定义的方法

    在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**定义：**

@classmethod
def 类方法名(cls):
    pass

- 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**

- 类方法的 **第一个参数** 应该是 `cls`

- 由 **哪一个类** 调用的方法，方法内的 `cls` 就是 **哪一个类的引用**

- 这个参数和 **实例方法** 的第一个参数是 `self` 类似

- **提示** 使用其他名称也可以，不过习惯使用 `cls`
3. 通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数

4. **在方法内部**
- 可以通过 `cls.` **访问类的属性**

- 也可以通过 `cls.` **调用其他的类方法**
  
  

**51. 静态方法**

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：

- 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**

- 也 **不需要** 访问 **类属性** 或者调用 **类方法**

- 这个时候，可以把这个方法封装成一个 **静态方法**

@staticmethod
def 静态方法名():
    pass

- **静态方法** 需要用 **修饰器** `@staticmethod` 来标识，**告诉解释器这是一个静态方法**

- 通过 **类名.** 调用 **静态方法**
